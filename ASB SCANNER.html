<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ASB Scanner ‚Äî MEXC ‚Ä¢ Target-Date Proximity ‚Ä¢ IST ‚Ä¢ MCap ‚Ä¢ RVOL ‚Ä¢ P@Target</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f172a; --panel2:#0d1628;
    --muted:#9fb0d4; --text:#e8eefc; --border:#22304a;
    --accent:#5eead4; --ok:#9ae6b4; --warn:#ffd166; --danger:#ff6b6b;
    --chip:#12203a; --shadow:0 10px 30px rgba(0,0,0,.25);
  }
  html,body{height:100%}
  body{
    margin:0;
    background:radial-gradient(1200px 600px at 10% -10%,#0d1a30 0,#0b1220 40%,#0a1020 100%);
    color:var(--text);
    font:14px system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;
  }
  *{box-sizing:border-box}
  .wrap{max-width:1320px;margin:22px auto;padding:0 14px}

  /* Topbar */
  .topbar{
    position:sticky; top:12px; z-index:9;
    display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    background:rgba(15,23,42,.72);
    border:1px solid var(--border);
    border-radius:18px;
    padding:10px 12px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(10px);
    margin-bottom:12px;
  }
  .brand{display:flex;gap:10px;align-items:center}
  .logo{
    width:38px;height:38px;border-radius:14px;
    background:linear-gradient(135deg, rgba(94,234,212,.95), rgba(96,165,250,.85));
    box-shadow:0 0 0 3px rgba(94,234,212,.08);
  }
  .brand h1{margin:0;font-size:14px;letter-spacing:.2px}
  .brand .sub{margin:0;color:var(--muted);font-size:12px}
  .top-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .btn2{
    background:#0c1426;color:var(--text);
    border:1px solid var(--border);
    border-radius:12px;
    padding:8px 10px; min-height:36px;
    cursor:pointer; user-select:none;
    transition:border-color .15s ease, transform .05s ease;
    text-decoration:none; display:inline-flex; align-items:center; justify-content:center;
  }
  .btn2:hover{transform:translateY(-1px);border-color:rgba(94,234,212,.55)}
  .btn2:active{transform:translateY(0)}
  .btn2.primary{border-color:rgba(94,234,212,.55); background:rgba(94,234,212,.10)}
  .btn2.blue{border-color:rgba(96,165,250,.55); background:rgba(96,165,250,.10)}
  .btn2.danger{border-color:rgba(239,68,68,.55); background:rgba(239,68,68,.10)}
  .btn2.warn{border-color:rgba(245,158,11,.55); background:rgba(245,158,11,.10)}
  .pill2{
    padding:6px 10px;border-radius:999px;border:1px solid var(--border);
    font-size:12px;background:var(--chip);color:var(--muted);display:inline-flex;align-items:center;gap:8px;
  }
  .pill2.on{border-color:rgba(34,197,94,.55);background:rgba(34,197,94,.10);color:rgba(167,243,208,.95)}
  .pill2.off{border-color:rgba(239,68,68,.55);background:rgba(239,68,68,.10);color:rgba(254,202,202,.95)}
  .pill2.admin{border-color:rgba(96,165,250,.65);background:rgba(96,165,250,.12);color:#dbeafe}

  /* Main panel */
  .panel{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--border);
    border-radius:18px;
    padding:12px 14px;
    box-shadow:var(--shadow);
  }
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:end}
  .col{display:flex;flex-direction:column;gap:6px;min-width:160px}
  h2{font-weight:700;letter-spacing:.2px;margin:0}
  label{font-size:12px;color:var(--muted)}
  input,select,button{
    background:#0c1426;color:var(--text);
    border:1px solid var(--border);
    border-radius:12px;
    padding:8px 10px;min-height:36px;outline:none;
    transition:border-color .15s ease, transform .05s ease;
  }
  input:focus,select:focus{border-color:#355080;box-shadow:0 0 0 3px rgba(53,80,128,.22)}
  button{cursor:pointer;user-select:none}
  .btn{background:linear-gradient(90deg,#1b2a44,#17354a);border-color:#2b3b5a;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .btn:hover{transform:translateY(-1px)} .btn:active{transform:translateY(0)}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px;display:inline-flex;align-items:center;gap:6px;background:var(--chip)}
  .note{color:var(--muted);font-size:12px}
  .stats{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
  .stat{padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;background:#0c1426}

  /* Table */
  .grid{margin-top:12px;border:1px solid var(--border);border-radius:18px;overflow:auto;height:54vh}
  table{width:100%;border-collapse:separate;border-spacing:0}
  thead th{
    position:sticky;top:0;
    background:linear-gradient(180deg,#111b2e,#0f172a);
    border-bottom:1px solid var(--border);
    z-index:2;font-weight:700;color:#cbd5f1;
    backdrop-filter:blur(4px)
  }
  th,td{padding:10px;text-align:right;white-space:nowrap}
  th:first-child,td:first-child{text-align:left}
  tbody tr:nth-child(odd){background:#0c1426}
  tbody tr:hover{background:#0e1830}
  thead th[data-k]{cursor:pointer;user-select:none;position:relative}
  thead th[data-k]::after{
    content:"";position:absolute;right:8px;top:50%;
    width:8px;height:8px;border-right:2px solid #6aa7a0;border-bottom:2px solid #6aa7a0;
    opacity:.35;transform:translateY(-50%) rotate(-45deg)
  }
  thead th.sort-asc::after{opacity:.9;transform:translateY(-50%) rotate(-135deg)}
  thead th.sort-desc::after{opacity:.9;transform:translateY(-50%) rotate(45deg)}

  .bar{width:120px;height:8px;border-radius:999px;background:#0c1426;border:1px solid var(--border);position:relative;display:inline-block;overflow:hidden}
  .bar>i{position:absolute;top:-3px;width:2px;height:14px;background:#6dd6c8;border-radius:1px}
  .bar .lo{left:0}.bar .hi{right:0}.bar .p{background:var(--ok)}
  @keyframes ping{0%{box-shadow:0 0 0 0 rgba(154,230,180,.35)}100%{box-shadow:0 0 0 10px rgba(154,230,180,0)}}
  .ping{animation:ping .9s cubic-bezier(.2,.7,.2,1) 1}

  .recs{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:12px}
  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--border);
    border-radius:16px;
    padding:10px;min-height:160px;position:relative;overflow:hidden
  }
  .card:before{
    content:"";position:absolute;inset:-40% -40% auto auto;width:120%;height:120%;
    background:radial-gradient(300px 120px at right -40px top -40px, rgba(94,234,212,.07), transparent 60%);
    pointer-events:none
  }
  .rec-list{max-height:22vh;overflow:auto}
  .rec-item{display:flex;justify-content:space-between;border-bottom:1px dashed #22304a;padding:8px 0;gap:8px}
  .rec-item:last-child{border-bottom:none}

  .skel{background:linear-gradient(90deg,#0f172a 25%,#13203a 37%,#0f172a 63%);background-size:400% 100%;animation:shimmer 1.2s ease-in-out infinite}
  @keyframes shimmer{0%{background-position:100% 0}100%{background-position:-100% 0}}

  .pill.bull{background:rgba(16,61,39,.55);border-color:#2b6b46;color:#9ae6b4}
  .pill.bear{background:rgba(61,16,16,.55);border-color:#6b2b2b;color:#ff7b7b}
  .pill.doji{background:rgba(61,49,16,.55);border-color:#6b5a2b;color:#ffd166}

  .trade-btn{
    display:inline-flex;align-items:center;justify-content:center;
    padding:7px 10px;border-radius:12px;
    border:1px solid rgba(94,234,212,.55);
    background:rgba(94,234,212,.10);
    color:var(--text); text-decoration:none; font-size:12px;
  }
  .trade-btn:hover{border-color:rgba(94,234,212,.85); background:rgba(94,234,212,.16)}

  /* Modal */
  .modal-backdrop{
    position:fixed; inset:0;
    background: rgba(0,0,0,.55);
    display:none; align-items:center; justify-content:center;
    padding:20px; z-index: 999;
  }
  .modal{
    width:min(860px, 100%);
    background: rgba(11,18,32,.98);
    border:1px solid var(--border);
    border-radius: 18px;
    box-shadow: var(--shadow);
    padding:16px;
  }
  .modal header{display:flex; align-items:center; justify-content:space-between; gap:12px}
  .modal h4{margin:0; font-size:16px}
  .modal .content{margin-top:12px; color:var(--muted); font-size:13px; line-height:1.55}
  .pricing{display:grid; grid-template-columns: repeat(3,1fr); gap:10px; margin-top:12px}
  .price-card{border:1px solid var(--border); border-radius:16px; padding:14px; background: rgba(15,23,42,.55)}
  .price{font-size:20px; color:var(--text); margin-top:6px}
  .ul{margin:10px 0 0; padding-left:18px}
  .ul li{margin:6px 0}
  .divider{height:1px; background: rgba(34,48,74,.7); margin:12px 0}

  @media (max-width: 980px){
    .recs{grid-template-columns:1fr}
    .grid{height:56vh}
    .pricing{grid-template-columns:1fr}
  }
</style>
</head>
<body>

<div class="wrap">

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>ASB Scanner</h1>
        <p class="sub">MEXC default trade ‚Ä¢ Pro unlock ‚Ä¢ Admin (your device)</p>
      </div>
    </div>
    <div class="top-actions">
      <span id="proBadge" class="pill2 off">Pro: Locked üîí</span>
      <span id="adminBadge" class="pill2 admin" style="display:none;">Admin ‚úÖ</span>

      <button id="btnShare" class="btn2" data-sound="click">Share</button>
      <a id="btnJoinMexc" class="btn2 primary" href="#" target="_blank" rel="noopener noreferrer">Join MEXC</a>

      <button id="btnPro" class="btn2 blue" data-sound="click">Go Pro</button>
      <button id="btnUnlock" class="btn2 primary" data-sound="click">Unlock</button>
      <button id="btnLock" class="btn2 danger" data-sound="click">Lock</button>

      <button id="btnAdmin" class="btn2 warn" data-sound="click">Admin</button>
      <button id="btnAdminOff" class="btn2 danger" data-sound="click">Admin Off</button>
    </div>
  </div>

  <!-- MAIN PANEL -->
  <div class="panel">
    <div class="row" style="align-items:center;justify-content:space-between">
      <h2>Target-Date Proximity <span class="note">‚Äî live % to Timeframe High/Low + P@Target (IST, 12-hour) + Day Close Dir</span></h2>
      <div class="row"><button id="refresh" class="btn" data-sound="click">Refresh</button></div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="col"><label>Target Date (IST day)</label><input type="date" id="date" data-sound="click"></div>
      <div class="col"><label>Target Time (IST, input 24h; displayed 12h)</label><input type="time" id="timeIst" step="60" data-sound="click"></div>
      <div class="col">
        <label>Timeframe (single candle)</label>
        <select id="tfSelect" data-sound="click">
          <option value="auto" selected>Auto (whole day / to time)</option>
          <option value="15m">15m</option><option value="30m">30m</option>
          <option value="1h">1h</option><option value="2h">2h</option>
          <option value="4h">4h</option><option value="6h">6h</option>
          <option value="8h">8h</option><option value="12h">12h</option>
          <option value="1d">1d</option><option value="3d">3d</option>
          <option value="1w">1w</option>
        </select>
      </div>
      <div class="col">
        <label>Market</label>
        <select id="marketType" data-sound="click">
          <option value="spot" selected>Spot</option>
          <option value="perp">Perpetual (USDT-M)</option>
        </select>
      </div>
      <div class="col" style="min-width:260px">
        <label>Exchanges</label>
        <div class="row" style="gap:8px;align-items:center">
          <!-- Default: MEXC checked -->
          <label class="pill"><input type="checkbox" class="exch" value="mexc" checked style="accent-color:#4fd1c5" data-sound="tick"> MEXC (spot)</label>
          <label class="pill"><input type="checkbox" class="exch" value="binance" style="accent-color:#4fd1c5" data-sound="tick"> Binance</label>
        </div>
      </div>
      <div class="col"><label>Top N / exchange</label>
        <select id="topn" data-sound="click"><option>20</option><option>60</option><option>100</option><option>200</option><option selected>300</option><option>500</option></select>
      </div>
      <div class="col"><label> </label><button id="loadTop" class="btn" data-sound="click">Load Top</button></div>
      <div class="col" style="flex:1;min-width:240px"><label>Quick search</label><input id="search" placeholder="Filter (e.g., BTC, ETH, MEXC)‚Ä¶"></div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="col"><label>Near High/Low threshold (%)</label><input type="number" id="threshold" value="0.25" step="0.01" min="0" data-sound="tick"></div>
      <div class="col"><label>Max Closeness % (optional)</label><input type="number" id="maxClose" placeholder="e.g. 0.20" step="0.01" min="0" data-sound="tick"></div>
      <div class="col"><label>Recent touches lookback (hrs)</label><input type="number" id="lookbackHrs" value="24" min="1" step="1" data-sound="tick"></div>
      <div class="col"><label>Only show recent touches</label><label class="pill"><input type="checkbox" id="filterRecent" style="margin-right:6px;accent-color:#4fd1c5" data-sound="tick"> Enabled</label></div>
      <div class="col"><label> </label><button id="scanRecentBtn" class="btn" data-sound="click">Scan Recent Touches</button></div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="col"><label>Min RVOL (√ó average)</label><input type="number" id="rvolMin" value="1.5" step="0.1" min="0" data-sound="tick"></div>
      <div class="col"><label>RVOL lookback (days)</label><input type="number" id="rvolDays" value="20" step="1" min="5" max="60" data-sound="tick"></div>
      <div class="col"><label>Filter by RVOL</label><label class="pill"><input type="checkbox" id="rvolOnly" style="margin-right:6px;accent-color:#4fd1c5" data-sound="tick"> Enabled</label></div>
      <div class="col"><label> </label><button id="rvolCompute" class="btn" data-sound="click">Compute RVOL</button></div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="col"><label>Market Cap preset</label>
        <select id="mcPreset" data-sound="click">
          <option value="">‚Äî Any ‚Äî</option><option value="200000000">‚â• 200M</option><option value="500000000">‚â• 500M</option><option value="1000000000">‚â• 1B</option><option value="5000000000">‚â• 5B</option>
        </select>
      </div>
      <div class="col"><label>M.Cap ‚â• (USD)</label><input type="number" id="mcMin" placeholder="enter any number" data-sound="tick"></div>
      <div class="col"><label>M.Cap ‚â§ (USD)</label><input type="number" id="mcMax" placeholder="(blank = no max)" data-sound="tick"></div>
      <div class="col"><label>CoinGecko mapping</label><button id="mcFetch" class="btn" data-sound="click">Fetch Market Caps</button></div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="col"><label>Compute P@Target (exact 1-min at time)</label><label class="pill"><input type="checkbox" id="ptOnlyNear" style="margin-right:6px;accent-color:#4fd1c5"> Only show near @Time</label></div>
      <div class="col"><label>Near @Time threshold (%)</label><input type="number" id="ptThr" value="0.25" step="0.01" min="0"></div>
      <div class="col"><label> </label><button id="ptCompute" class="btn" data-sound="click">Get P@Target (1m)</button></div>
    </div>

    <div class="stats">
      <span class="stat">Rows: <strong id="rowCount">0</strong></span>
      <span class="stat">Live sockets: <strong id="wsCount">0</strong></span>
      <span class="stat">MC known: <strong id="mcKnown">0</strong></span>
      <span class="stat">RVOL computed: <strong id="rvKnown">0</strong></span>
      <span class="stat">P@Target known: <strong id="ptKnown">0</strong></span>
      <span class="stat">Status: <strong id="statusTxt">Idle</strong></span>
    </div>

    <p class="note" style="margin-top:6px">
      % to High = ((High ‚àí Price)/High)√ó100 ‚Ä¢ % to Low = ((Price ‚àí Low)/Low)√ó100 ‚Ä¢ <b>Closeness %</b> = min(% to High, % to Low). ‚Ä¢ <b>% to P@Target</b> = |Price ‚àí P@Target| √∑ P@Target √ó 100.
    </p>
  </div>

  <!-- TABLE -->
  <div class="grid">
    <table id="tbl" aria-live="polite">
      <thead>
        <tr>
          <th data-k="exchange">Exchange</th>
          <th data-k="symbol">Symbol</th>
          <th data-k="market">Market</th>
          <th data-k="price">Live Price</th>
          <th data-k="high">TF High</th>
          <th data-k="low">TF Low</th>
          <th data-k="rangePct">%(Hi‚ÜîLow)</th>
          <th data-k="toHighPct">% to High</th>
          <th data-k="toLowPct">% to Low</th>
          <th data-k="closeness">Closeness %</th>
          <th data-k="posPct">Position %</th>
          <th data-k="bar">Proximity</th>
          <th data-k="pAt">P@Target</th>
          <th data-k="toPtPct">% to P@Target</th>
          <th data-k="rvol">RVOL</th>
          <th data-k="qvol24h">24h $Vol</th>
          <th data-k="avgQVol">Avg $Vol (N)</th>
          <th data-k="mcap">M.Cap (USD)</th>
          <th data-k="date">Candle (IST)</th>
          <th data-k="daydir">Day Close</th>
          <th>Trade (MEXC)</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr class="skel"><td colspan="21" style="height:120px"></td></tr>
      </tbody>
    </table>
  </div>

  <!-- RADARS -->
  <div class="recs">
    <div class="card"><h3 style="margin:0 0 6px">Breakout radar ‚Äî Near High</h3><div id="recHigh" class="rec-list"></div></div>
    <div class="card"><h3 style="margin:0 0 6px">Mean-revert radar ‚Äî Near Low</h3><div id="recLow" class="rec-list"></div></div>
    <div class="card"><h3 style="margin:0 0 6px">Recent Touches (‚â§ lookback, IST)</h3><div id="recTouch" class="rec-list"></div></div>
  </div>

  <p class="note" style="margin-top:10px">
    MEXC spot runs via REST polling. Binance uses WebSocket (if enabled). Market-cap uses CoinGecko (best-effort symbol match).
  </p>

</div>

<!-- MODAL -->
<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <header>
      <h4 id="modalTitle">Modal</h4>
      <button class="btn2" id="modalClose" data-sound="click">Close</button>
    </header>
    <div class="content" id="modalBody"></div>
  </div>
</div>

<script>
(function(){
  /************************************************************
   * CONFIG (EDIT THESE)
   ************************************************************/
  const CONFIG = {
    // ‚úÖ YOUR MEXC REFERRAL LINK:
    MEXC_REF: "https://promote.mexc.co/r/5S4fzXCz",

    // Put your Razorpay / Stripe payment link here:
    PRO_PAYMENT_LINK: "https://razorpay.com/",

    // Users can unlock with these codes (change anytime):
    PRO_CODES: ["ASBPRO2025","ASBVIP","ASBTRADER"],

    // Admin PIN for YOU (device-only). Anyone can view page-source, so this is NOT secure.
    // For real security, you need a backend login.
    ADMIN_PIN: "AMIR-ADMIN-1234",

    // Gate features behind Pro (admin always has them):
    PRO_GATES: { RVOL:true, MCAP:true, PTARGET:true, RECENT_TOUCHES:false }
  };

  /************************************************************
   * Pro/Admin (device-only)
   ************************************************************/
  let proUnlocked = (localStorage.getItem("asb_pro") === "1");
  let isAdmin = (localStorage.getItem("asb_admin") === "1");
  const proBadge = document.getElementById("proBadge");
  const adminBadge = document.getElementById("adminBadge");

  function hasPro(){ return proUnlocked || isAdmin; }

  function setBadges(){
    if(isAdmin){
      adminBadge.style.display="inline-flex";
      proBadge.classList.remove("off"); proBadge.classList.add("on");
      proBadge.textContent="Pro: Unlocked ‚úÖ";
      return;
    }
    adminBadge.style.display="none";
    if(proUnlocked){
      proBadge.classList.remove("off"); proBadge.classList.add("on");
      proBadge.textContent="Pro: Unlocked ‚úÖ";
    }else{
      proBadge.classList.remove("on"); proBadge.classList.add("off");
      proBadge.textContent="Pro: Locked üîí";
    }
  }

  function openModal(title, html){
    document.getElementById("modalTitle").textContent = title;
    document.getElementById("modalBody").innerHTML = html;
    document.getElementById("modalBackdrop").style.display = "flex";
  }
  function closeModal(){ document.getElementById("modalBackdrop").style.display = "none"; }

  function openProModal(extraMsg=""){
    openModal("ASB Pro", `
      ${extraMsg ? `<div class="pill" style="border-color:rgba(245,158,11,.55);background:rgba(245,158,11,.10);color:#ffd166;margin-bottom:10px;">${extraMsg}</div>` : ""}
      <p><b>Go Pro</b> to unlock premium features (RVOL / Market Cap / P@Target).</p>

      <div class="pricing">
        <div class="price-card">
          <div class="note">Starter</div>
          <div class="price">‚Çπ499 / month</div>
          <ul class="ul"><li>RVOL tools</li><li>Market-cap filter</li><li>Priority updates</li></ul>
        </div>
        <div class="price-card">
          <div class="note">Pro</div>
          <div class="price">‚Çπ999 / month</div>
          <ul class="ul"><li>All Starter</li><li>P@Target tools</li><li>Faster workflow</li></ul>
        </div>
        <div class="price-card">
          <div class="note">VIP</div>
          <div class="price">‚Çπ1999 / month</div>
          <ul class="ul"><li>All Pro</li><li>Alerts (Telegram/WhatsApp)</li><li>Daily top setups</li></ul>
        </div>
      </div>

      <div class="divider"></div>

      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <a class="btn2 blue" href="${CONFIG.PRO_PAYMENT_LINK}" target="_blank" rel="noopener noreferrer">Pay & Get Pro</a>
        <button class="btn2 primary" id="modalUnlockBtn">I already have a code</button>
      </div>

      <p class="note" style="margin-top:10px">
        Admin is stored on <b>your device</b>. For real ‚Äúuser accounts‚Äù, you need a backend.
      </p>
    `);
    setTimeout(()=>{
      const b=document.getElementById("modalUnlockBtn");
      if(b) b.onclick = ()=>unlockPro();
    },0);
  }

  function unlockPro(){
    const code = prompt("Enter Pro Access Code:");
    if(!code) return;
    if(CONFIG.PRO_CODES.includes(code.trim())){
      proUnlocked=true;
      localStorage.setItem("asb_pro","1");
      setBadges();
      alert("Pro unlocked ‚úÖ");
      closeModal();
    }else alert("Invalid code.");
  }
  function lockPro(){
    proUnlocked=false;
    localStorage.removeItem("asb_pro");
    setBadges();
  }
  function adminOn(){
    const pin = prompt("Enter Admin PIN (device-only):");
    if(!pin) return;
    if(pin.trim() === CONFIG.ADMIN_PIN){
      isAdmin=true;
      localStorage.setItem("asb_admin","1");
      setBadges();
      alert("Admin enabled ‚úÖ (this device)");
    } else alert("Wrong PIN.");
  }
  function adminOff(){
    isAdmin=false;
    localStorage.removeItem("asb_admin");
    setBadges();
    alert("Admin disabled.");
  }

  // topbar buttons
  document.getElementById("btnJoinMexc").href = CONFIG.MEXC_REF;
  document.getElementById("modalClose").addEventListener("click", closeModal);
  document.getElementById("modalBackdrop").addEventListener("click", (e)=>{ if(e.target.id==="modalBackdrop") closeModal(); });
  document.getElementById("btnPro").addEventListener("click", ()=>openProModal());
  document.getElementById("btnUnlock").addEventListener("click", unlockPro);
  document.getElementById("btnLock").addEventListener("click", lockPro);
  document.getElementById("btnAdmin").addEventListener("click", adminOn);
  document.getElementById("btnAdminOff").addEventListener("click", adminOff);

  async function shareSite(){
    const url = location.href;
    try{
      if(navigator.share) await navigator.share({title: document.title, text: "ASB Scanner", url});
      else { await navigator.clipboard.writeText(url); alert("Link copied: " + url); }
    }catch{
      try{ await navigator.clipboard.writeText(url); }catch{}
    }
  }
  document.getElementById("btnShare").addEventListener("click", shareSite);

  setBadges();

  /************************************************************
   * Sound (small)
   ************************************************************/
  let audioCtx=null;
  const prefersReduced=matchMedia('(prefers-repanic'); // fallback safe? no
})();
</script>

<script>
(function(){
  // ---- sound (safe) ----
  let audioCtx=null;
  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  function beep({freq=520,dur=70,type='triangle',vol=0.08}={}){
    try{ audioCtx ||= new (window.AudioContext||window.webkitAudioContext)(); }catch(_){ return; }
    const t=audioCtx.currentTime, o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.setValueAtTime(0.0001,t);
    g.gain.linearRampToValueAtTime(vol,t+.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur/1e3);
    o.connect(g).connect(audioCtx.destination);
    o.start(t); o.stop(t+dur/1e3);
  }
  const play={click:()=>beep(), sort:()=>beep({freq:640,dur:60,type:'sine'}), done:()=>{beep({freq:660});setTimeout(()=>beep({freq:990}),60)}};
  document.addEventListener("click",(e)=>{
    const el = e.target.closest("[data-sound]");
    if(!el || prefersReduced) return;
    const k = el.getAttribute("data-sound");
    if(play[k]) play[k]();
  }, true);

  // --- DOM refs ---
  const $=q=>document.querySelector(q), $$=q=>Array.from(document.querySelectorAll(q));
  const tbody=$("#tbody"), rowCount=$("#rowCount"), wsCount=$("#wsCount"), statusTxt=$("#statusTxt");
  const mcKnown=$("#mcKnown"), recHigh=$("#recHigh"), recLow=$("#recLow"), recTouch=$("#recTouch");
  const rvKnown=$("#rvKnown"), ptKnown=$("#ptKnown");

  // Config from first script (already declared in global scope)
  const CONFIG = window.CONFIG || null; // (not used here directly)

  // Formatters
  const NF=new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
  const NF3=new Intl.NumberFormat(undefined,{maximumFractionDigits:3});
  const NFi0=new Intl.NumberFormat(undefined,{maximumFractionDigits:0});
  const isF=x=>Number.isFinite(x);
  const fmtN=(x,dp=3)=> isF(x)? (Math.abs(x)>=1000? NF.format(x):(+x).toFixed(dp)):"‚Äî";
  const fmtPct=x=> isF(x)? NF3.format(x)+"%":"‚Äî";
  const fmtInt=x=> isF(x)? NFi0.format(x):"‚Äî";

  // TIME FIX (IST)
  const IST_OFFSET_MS = 5.5 * 3600e3;
  const IST_TZ = "Asia/Kolkata";
  const IST_DATE_FMT = new Intl.DateTimeFormat("en-CA", { timeZone: IST_TZ, year:"numeric", month:"2-digit", day:"2-digit" });
  const IST_DT_FMT_12H = new Intl.DateTimeFormat("en-US", {
    timeZone: IST_TZ, year:"numeric", month:"2-digit", day:"2-digit", hour:"numeric", minute:"2-digit", hour12:true
  });

  function parseYMD(dateStr){
    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr||"");
    if(!m) return null;
    return {y:+m[1], mo:+m[2], d:+m[3]};
  }
  function parseHM(timeStr){
    if(!timeStr) return null;
    const m = /^(\d{1,2}):(\d{2})$/.exec(timeStr);
    if(!m) return null;
    let hh = Math.max(0, Math.min(23, +m[1]));
    let mm = Math.max(0, Math.min(59, +m[2]));
    return {hh, mm};
  }
  function istDayStartUtcMs(istDateStr){
    const p=parseYMD(istDateStr); if(!p) return NaN;
    const utcMidnightAsIf = Date.UTC(p.y, p.mo-1, p.d, 0, 0, 0, 0);
    return utcMidnightAsIf - IST_OFFSET_MS;
  }
  function istDateTimeToUtcMs(istDateStr, istTimeStr){
    const p=parseYMD(istDateStr); const t=parseHM(istTimeStr);
    if(!p || !t) return NaN;
    const utcAsIf = Date.UTC(p.y, p.mo-1, p.d, t.hh, t.mm, 0, 0);
    return utcAsIf - IST_OFFSET_MS;
  }
  function toIST12(ms){
    if(!isF(ms)) return "‚Äî";
    const parts = IST_DT_FMT_12H.formatToParts(new Date(ms));
    const get = (type)=> (parts.find(p=>p.type===type)?.value || "");
    const MM=get("month"), DD=get("day"), YY=get("year");
    const hh=get("hour"), mm=get("minute"), ap=get("dayPeriod");
    return `${YY}-${MM}-${DD} ${hh}:${mm} ${ap} IST`;
  }
  function istDateLabelFromMs(ms){
    if(!isF(ms)) return "‚Äî";
    return IST_DATE_FMT.format(new Date(ms));
  }
  function utcWindowForIst(istDateStr, istTimeStr){
    const start = istDayStartUtcMs(istDateStr);
    const last  = start + 24*3600e3 - 1;
    if(!istTimeStr) return { start, end:last };
    let end = istDateTimeToUtcMs(istDateStr, istTimeStr);
    if(!isF(end)) end = last;
    if(end < start) end = start;
    if(end > last) end = last;
    return { start, end };
  }
  function timeLabelISTForWindow(istDateStr, istTimeStr){
    if(istTimeStr){
      const end = istDateTimeToUtcMs(istDateStr, istTimeStr);
      return `${istDateStr} ${toIST12(end).split(" ").slice(1).join(" ")}`;
    }
    const end = istDayStartUtcMs(istDateStr) + 24*3600e3 - 1;
    return `${istDateStr} ${toIST12(end).split(" ").slice(1).join(" ")}`;
  }

  const intervalMsMap={"1m":60e3,"3m":180e3,"5m":300e3,"15m":900e3,"30m":1800e3,"1h":3600e3,"2h":7200e3,"4h":14400e3,"6h":21600e3,"8h":28800e3,"12h":43200e3,"1d":86400e3,"3d":259200e3,"1w":604800e3};
  function candleIstLabel(openMs, interval){
    if(!isF(openMs)) return "‚Äî";
    const ms = intervalMsMap[interval] || 0;
    const a = toIST12(openMs);
    const b = toIST12(openMs + Math.max(0, ms-1));
    return `${interval} ‚Ä¢ ${a} ‚Üí ${b}`;
  }

  // helpers
  function compute(price,high,low){
    const r={toHighPct:null,toLowPct:null,posPct:null,closer:"‚Äî",closeness:null,rangePct:null};
    if(!(isF(price)&&isF(high)&&isF(low))) return r;
    const range=high-low; if(!(range>0)) return r;
    const toH=((high-price)/high)*100, toL=((price-low)/low)*100, pos=((price-low)/range)*100;
    r.toHighPct=toH; r.toLowPct=toL; r.posPct=pos; r.rangePct=((high/low)-1)*100;
    const a=Math.max(toH,0), b=Math.max(toL,0);
    r.closeness=Math.min(a,b);
    r.closer=(a<b)?"High":(b<a?"Low":"Equal");
    return r;
  }
  const proxBar=posPct=>{
    if(!isF(posPct)) return "";
    const clamped = Math.max(0, Math.min(100, posPct));
    const px = (clamped/100)*118;
    return `<span class="bar"><i class="lo"></i><i class="hi"></i><i class="p" style="left:${px}px"></i></span>`;
  };

  // Always Trade on MEXC (pair page)
  function tradeUrl(symbol){
    return `https://www.mexc.com/exchange/${encodeURIComponent(symbol)}`;
  }

  // Adapters
  const Adapters={
    mexc:{
      key:"mexc",name:"MEXC",
      base:()=> "https://api.mexc.com",
      async topSymbols(m,n){
        if(m==="perp") return [];
        const r=await fetch(this.base()+"/api/v3/ticker/24hr");
        const data=await r.json();
        const usdt=data.filter(d=>d.symbol.endsWith("USDT"));
        usdt.sort((a,b)=>(+b.quoteVolume)-(+a.quoteVolume));
        return usdt.slice(0,n).map(d=>d.symbol);
      },
      async klineHL_candleAt(m,sym,interval,istDateStr,istTimeStr){
        if(m==="perp") return null;
        const {end}=utcWindowForIst(istDateStr,istTimeStr);
        const ms=intervalMsMap[interval]; if(!ms) return null;
        const r=await fetch(`${this.base()}/api/v3/klines?symbol=${sym}&interval=${interval}&endTime=${end}&limit=3`);
        if(!r.ok) return null;
        const arr=await r.json(); if(!arr.length) return null;
        let chosen=null;
        for(const k of arr){const o=k[0]; if(o<=end && end<o+ms){chosen=k;break}}
        if(!chosen) chosen=arr[arr.length-1];
        return chosen?{high:+chosen[2],low:+chosen[3],open:+chosen[0]}:null;
      },
      async klineDayOHLC(m,sym,istDateStr){
        if(m==="perp") return null;
        const {start,end}=utcWindowForIst(istDateStr,null);
        const r=await fetch(`${this.base()}/api/v3/klines?symbol=${sym}&interval=1d&startTime=${start}&endTime=${end}&limit=1`);
        if(!r.ok) return null;
        const a=await r.json(); if(!a.length) return null;
        return {open:+a[0][1],high:+a[0][2],low:+a[0][3],close:+a[0][4],openTs:+a[0][0]};
      },
      async klineHL_window(m,sym,istDateStr,istTimeStr){
        if(m==="perp") return null;
        const {start,end}=utcWindowForIst(istDateStr,istTimeStr);
        const interval=((end-start)/60000)<=999?"1m":"5m";
        const r=await fetch(`${this.base()}/api/v3/klines?symbol=${sym}&interval=${interval}&startTime=${start}&endTime=${end}&limit=1000`);
        if(!r.ok) return null;
        const arr=await r.json(); if(!arr.length) return null;
        let hi=-Infinity,lo=Infinity;
        for(const k of arr){const h=+k[2],l=+k[3]; if(h>hi)hi=h; if(l<lo)lo=l}
        return {high:hi,low:lo};
      },
      async priceAtTarget(m,sym,istDateStr,istTimeStr){
        if(m==="perp") return null;
        const end=istDateTimeToUtcMs(istDateStr,istTimeStr);
        const minuteOpen=Math.floor(end/60000)*60000;
        const r=await fetch(`${this.base()}/api/v3/klines?symbol=${sym}&interval=1m&startTime=${minuteOpen}&endTime=${minuteOpen+60000}&limit=1`);
        if(!r.ok) return null;
        const a=await r.json(); if(!a.length) return null;
        return +a[0][4];
      },
      async batchPrices(m,syms){
        if(m==="perp") return new Map();
        const r=await fetch(this.base()+"/api/v3/ticker/price");
        if(!r.ok) return new Map();
        const all=await r.json();
        const set=new Set(syms),map=new Map();
        for(const it of all){ if(set.has(it.symbol)) map.set(it.symbol,+it.price) }
        return map;
      },
      async batch24hStats(m,syms){
        if(m==="perp") return new Map();
        const r=await fetch(this.base()+"/api/v3/ticker/24hr");
        if(!r.ok) return new Map();
        const data=await r.json();
        const set=new Set(syms),map=new Map();
        for(const d of data){ if(set.has(d.symbol)) map.set(d.symbol,{qvol:+d.quoteVolume||0}) }
        return map;
      },
      connectWS(){ return []; }
    },

    // optional: Binance if you tick it
    binance:{
      key:"binance",name:"Binance",
      base:(m)=>m==="perp"?"https://fapi.binance.com":"https://api.binance.com",
      ws:(m)=>m==="perp"?"wss://fstream.binance.com":"wss://stream.binance.com:9443",
      async topSymbols(m,n){
        const r=await fetch(this.base(m)+(m==="perp"?"/fapi/v1/ticker/24hr":"/api/v3/ticker/24hr"));
        const data=await r.json();
        const filt=data.filter(d=>d.symbol.endsWith("USDT") && !/UPUSDT|DOWNUSDT/.test(d.symbol));
        filt.sort((a,b)=>(+b.quoteVolume)-(+a.quoteVolume));
        return filt.slice(0,n).map(d=>d.symbol);
      },
      async klineHL_candleAt(m,sym,interval,istDateStr,istTimeStr){
        const {end}=utcWindowForIst(istDateStr,istTimeStr);
        const ms=intervalMsMap[interval]; if(!ms) return null;
        const ep=m==="perp"?"/fapi/v1/klines":"/api/v3/klines";
        const url=`${this.base(m)}${ep}?symbol=${sym}&interval=${interval}&endTime=${end}&limit=3`;
        const r=await fetch(url); if(!r.ok) return null;
        const arr=await r.json(); if(!arr.length) return null;
        let chosen=null;
        for(const k of arr){const o=k[0]; if(o<=end && end<o+ms){chosen=k;break}}
        if(!chosen) chosen=arr[arr.length-1];
        return chosen?{high:+chosen[2],low:+chosen[3],open:+chosen[0]}:null;
      },
      async klineDayOHLC(m,sym,istDateStr){
        const {start,end}=utcWindowForIst(istDateStr,null);
        const ep=m==="perp"?"/fapi/v1/klines":"/api/v3/klines";
        const r=await fetch(`${this.base(m)}${ep}?symbol=${sym}&interval=1d&startTime=${start}&endTime=${end}&limit=1`);
        const a=await r.json(); if(!Array.isArray(a)||!a.length) return null;
        return {open:+a[0][1],high:+a[0][2],low:+a[0][3],close:+a[0][4],openTs:+a[0][0]};
      },
      async klineHL_window(m,sym,istDateStr,istTimeStr){
        const {start,end}=utcWindowForIst(istDateStr,istTimeStr);
        const interval=((end-start)/60000)<=999?"1m":"5m";
        const ep=m==="perp"?"/fapi/v1/klines":"/api/v3/klines";
        const r=await fetch(`${this.base(m)}${ep}?symbol=${sym}&interval=${interval}&startTime=${start}&endTime=${end}&limit=1000`);
        if(!r.ok) return null;
        const arr=await r.json(); if(!arr.length) return null;
        let hi=-Infinity,lo=Infinity;
        for(const k of arr){const h=+k[2],l=+k[3]; if(h>hi)hi=h; if(l<lo)lo=l}
        return {high:hi,low:lo};
      },
      async priceAtTarget(m,sym,istDateStr,istTimeStr){
        const end=istDateTimeToUtcMs(istDateStr,istTimeStr);
        const minuteOpen=Math.floor(end/60000)*60000;
        const ep=m==="perp"?"/fapi/v1/klines":"/api/v3/klines";
        const url=`${this.base(m)}${ep}?symbol=${sym}&interval=1m&startTime=${minuteOpen}&endTime=${minuteOpen+60000}&limit=1`;
        const r=await fetch(url); if(!r.ok) return null;
        const a=await r.json(); if(!Array.isArray(a)||!a.length) return null;
        return +a[0][4];
      },
      async batchPrices(m,syms){
        const r=await fetch(this.base(m)+(m==="perp"?"/fapi/v1/ticker/price":"/api/v3/ticker/price"));
        const all=await r.json();
        const set=new Set(syms),map=new Map();
        for(const it of all){ if(set.has(it.symbol)) map.set(it.symbol,+it.price) }
        return map;
      },
      async batch24hStats(m,syms){
        const r=await fetch(this.base(m)+(m==="perp"?"/fapi/v1/ticker/24hr":"/api/v3/ticker/24hr"));
        if(!r.ok) return new Map();
        const data=await r.json();
        const set=new Set(syms),map=new Map();
        for(const d of data){ if(set.has(d.symbol)) map.set(d.symbol,{qvol:+d.quoteVolume||0}) }
        return map;
      },
      connectWS(m,syms,onPrice){
        const chunks=[];
        for(let i=0;i<syms.length;i+=180) chunks.push(syms.slice(i,i+180));
        return chunks.map(chunk=>{
          const path=chunk.map(s=>`${s.toLowerCase()}@miniTicker`).join("/");
          const ws=new WebSocket(`${this.ws(m)}/stream?streams=${path}`);
          ws.onmessage=ev=>{
            const msg=JSON.parse(ev.data),d=msg.data||msg;
            const sym=(d.s||"").toUpperCase();
            const price=d.c?+d.c:(d.p?+d.p:NaN);
            if(sym && isF(price)) onPrice(sym,price);
          };
          ws.onerror=()=>{ try{ws.close()}catch{} };
          return ws;
        });
      }
    }
  };

  // State
  const state={
    dateStr:null,timeIst:null,marketType:"spot",exchanges:new Set(["mexc"]),timeframe:"auto",
    rows:new Map(),symbols:[],sockets:[],restPoll:null,
    sortKey:"closeness",sortDir:1,lookbackHrs:24,maxClose:null,
    cg:{list:null,mcapByBase:new Map()}, rvol:{days:20}, pt:{}
  };

  // Default date
  $("#date").value = istDateLabelFromMs(Date.now());

  function setStatus(s){ statusTxt.textContent=s; }

  // Market cap (CoinGecko)
  async function ensureCGList(){
    if(state.cg.list) return;
    const r=await fetch("https://api.coingecko.com/api/v3/coins/list?include_platform=false");
    state.cg.list=await r.json();
  }
  const baseAsset=s=> s.replace(/(USDT|BUSD|USDC|FDUSD|TUSD|USD)$/,'');
  function pickIdsForBases(bases){
    const idsByBase=new Map();
    for(const b of bases){
      const sym=b.toLowerCase();
      const matches=(state.cg.list||[]).filter(x=>x.symbol===sym);
      let id=null;
      if(matches.length===1) id=matches[0].id;
      else if(matches.length>1){
        const preferred=matches.find(x=>/^(bitcoin|ethereum|tether|solana|ripple|cardano|dogecoin|tron|polkadot|litecoin)$/i.test(x.name));
        id=(preferred||matches[0]).id;
      }
      if(id) idsByBase.set(b,id);
    }
    return idsByBase;
  }

  function hasPro(){
    // same storage as first script
    return (localStorage.getItem("asb_pro")==="1") || (localStorage.getItem("asb_admin")==="1");
  }
  function openPro(msg){ 
    // reuse modal in DOM
    const title="ASB Pro";
    const html=`<p class="note">${msg||"This is a Pro feature."}</p>
      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn2 blue" id="goProBtn">Go Pro</button>
        <button class="btn2 primary" id="unlockBtn">Unlock Code</button>
      </div>`;
    document.getElementById("modalTitle").textContent=title;
    document.getElementById("modalBody").innerHTML=html;
    document.getElementById("modalBackdrop").style.display="flex";
    setTimeout(()=>{
      const go=document.getElementById("goProBtn");
      const un=document.getElementById("unlockBtn");
      if(go) go.onclick=()=>document.getElementById("btnPro").click();
      if(un) un.onclick=()=>document.getElementById("btnUnlock").click();
    },0);
  }

  async function fetchMarketCaps(){
    if(!hasPro()){ openPro("Market-cap fetch is Pro."); return; }
    setStatus("Fetching market caps‚Ä¶");
    try{
      await ensureCGList();
      const bases=new Set(Array.from(state.rows.values()).map(r=>baseAsset(r.symbol)));
      const idsByBase=pickIdsForBases(bases);
      const ids=[...idsByBase.values()];
      const mcapById=new Map();
      for(let i=0;i<ids.length;i+=200){
        const chunk=ids.slice(i,i+200);
        const r=await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${encodeURIComponent(chunk.join(','))}&per_page=250&page=1`);
        if(r.ok){
          const arr=await r.json();
          for(const it of arr){ if(it&&it.id) mcapById.set(it.id,it.market_cap??null); }
        }
        await new Promise(res=>setTimeout(res,140));
      }
      state.cg.mcapByBase.clear();
      idsByBase.forEach((id,base)=> state.cg.mcapByBase.set(base, mcapById.get(id)??null));

      let known=0;
      for(const r of state.rows.values()){
        const base=baseAsset(r.symbol);
        r.mcap=state.cg.mcapByBase.get(base)??null;
        if(r.mcap) known++;
      }
      mcKnown.textContent=String(known);
      scheduleRender(); computeRecommendations(); setStatus("Ready"); play.done();
    }catch{
      setStatus("CoinGecko error");
    }
  }

  // Render
  let needsRender=false;
  function scheduleRender(){
    if(needsRender) return;
    needsRender=true;
    (requestAnimationFrame||setTimeout)(()=>{needsRender=false; render();},16);
  }

  function render(){
    const q=($("#search").value||"").trim().toUpperCase();
    const filterRecent=$("#filterRecent").checked;
    const rvolOnly=$("#rvolOnly").checked;
    const minRV=Math.max(0, parseFloat($("#rvolMin").value||"0")||0);
    const ptOnlyNear=$("#ptOnlyNear").checked;
    const ptThr=Math.max(0, parseFloat($("#ptThr").value||"0")||0);

    const preset=$("#mcPreset").value||"";
    if(preset) $("#mcMin").value=preset;

    const mcMin=parseFloat($("#mcMin").value||"");
    const mcMax=parseFloat($("#mcMax").value||"");
    const hasMin=Number.isFinite(mcMin), hasMax=Number.isFinite(mcMax);

    const maxCloseVal=$("#maxClose").value.trim();
    state.maxClose=maxCloseVal===""?null:Math.max(0,parseFloat(maxCloseVal)||0);

    let rows=Array.from(state.rows.values()).filter(r=>{
      if(q && !(`${r.exchangeName} ${r.symbol} ${r.market}`.toUpperCase().includes(q))) return false;
      if(filterRecent && !r.touchedAnyRecent) return false;
      if(state.maxClose!=null && (!isF(r.closeness)||r.closeness>state.maxClose)) return false;
      if(rvolOnly){ if(!isF(r.rvol) || r.rvol<minRV) return false; }
      if(ptOnlyNear){ if(!isF(r.toPtPct) || Math.abs(r.toPtPct)>ptThr) return false; }
      if(hasMin||hasMax){
        if(r.mcap==null) return false;
        if(hasMin && r.mcap<mcMin) return false;
        if(hasMax && r.mcap>mcMax) return false;
      }
      return true;
    });

    rows.sort((a,b)=>{
      const k=state.sortKey, dir=state.sortDir;
      let av=a[k], bv=b[k];
      const numCols=["price","high","low","toHighPct","toLowPct","posPct","closeness","mcap","rangePct","rvol","qvol24h","avgQVol","toPtPct","pAt"];
      const isNum=numCols.includes(k);
      if(isNum){ av=(isF(av)?av:Infinity); bv=(isF(bv)?bv:Infinity); }
      else { av=(av??""); bv=(bv??""); }
      if(av<bv) return -1*dir;
      if(av>bv) return 1*dir;
      return 0;
    });

    const frag=document.createDocumentFragment();
    if(!rows.length){
      const tr=document.createElement('tr');
      tr.innerHTML=`<td colspan="21" class="note">No rows match your filters.</td>`;
      frag.appendChild(tr);
    }else{
      for(const r of rows){
        const dirClass = r.dayDir==="Bullish"?"bull":(r.dayDir==="Bearish"?"bear":(r.dayDir==="Doji"?"doji":""));
        const dirHtml = r.dayDir? `<span class="pill ${dirClass}">${r.dayDir}</span>` : "‚Äî";
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td>${r.exchangeName}</td>
          <td><strong>${r.symbolDisp}</strong></td>
          <td class="note">${r.market==="perp"?"Perp":"Spot"}</td>
          <td>${fmtN(r.price)}</td>
          <td>${fmtN(r.high)}</td>
          <td>${fmtN(r.low)}</td>
          <td>${fmtPct(r.rangePct)}</td>
          <td>${fmtPct(r.toHighPct)}</td>
          <td>${fmtPct(r.toLowPct)}</td>
          <td>${isF(r.closeness)?fmtN(r.closeness):"‚Äî"}%</td>
          <td>${isF(r.posPct)?r.posPct.toFixed(2):"‚Äî"}%</td>
          <td>${proxBar(r.posPct)}</td>
          <td>${isF(r.pAt)?fmtN(r.pAt):"‚Äî"}</td>
          <td>${isF(r.toPtPct)?fmtN(Math.abs(r.toPtPct)):"‚Äî"}%</td>
          <td>${isF(r.rvol)?r.rvol.toFixed(2):"‚Äî"}</td>
          <td>${isF(r.qvol24h)?("$"+fmtInt(r.qvol24h)):"‚Äî"}</td>
          <td>${isF(r.avgQVol)?("$"+fmtInt(r.avgQVol)):"‚Äî"}</td>
          <td>${r.mcap? r.mcap.toLocaleString():"‚Äî"}</td>
          <td class="note">${r.date||"‚Äî"}</td>
          <td>${dirHtml}</td>
          <td><a class="trade-btn" href="${tradeUrl(r.symbol)}" target="_blank" rel="noopener noreferrer">Trade</a></td>
        `;
        frag.appendChild(tr);
      }
    }
    tbody.replaceChildren(frag);
    rowCount.textContent=String(rows.length);

    $$("thead th").forEach(th=>th.classList.remove("sort-asc","sort-desc"));
    const th=document.querySelector(`thead th[data-k="${state.sortKey}"]`);
    if(th) th.classList.add(state.sortDir===1?"sort-asc":"sort-desc");

    if(!prefersReduced) tbody.querySelectorAll('.bar .p').forEach(el=>{el.classList.remove('ping'); void el.offsetWidth; el.classList.add('ping');});
  }

  function computeRecommendations(){
    const filterRecent=$("#filterRecent").checked;
    const maxClose=state.maxClose;

    const rvolOnly=$("#rvolOnly").checked;
    const minRV=Math.max(0, parseFloat($("#rvolMin").value||"0")||0);

    const mcMin=parseFloat($("#mcMin").value||"");
    const mcMax=parseFloat($("#mcMax").value||"");
    const hasMin=Number.isFinite(mcMin), hasMax=Number.isFinite(mcMax);

    const pool=Array.from(state.rows.values()).filter(r=>{
      if(!isF(r.high)||!isF(r.low)||!isF(r.price)||!isF(r.closeness)) return false;
      if(filterRecent && !r.touchedAnyRecent) return false;
      if(maxClose!=null && r.closeness>maxClose) return false;
      if(rvolOnly && (!isF(r.rvol)||r.rvol<minRV)) return false;
      if(hasMin||hasMax){
        if(r.mcap==null) return false;
        if(hasMin && r.mcap<mcMin) return false;
        if(hasMax && r.mcap>mcMax) return false;
      }
      return true;
    });

    const nearHigh=pool.filter(r=> (r.toHighPct??Infinity) <= (r.toLowPct??Infinity)).sort((a,b)=>a.closeness-b.closeness).slice(0,20);
    const nearLow =pool.filter(r=> (r.toLowPct??Infinity)  < (r.toHighPct??Infinity)).sort((a,b)=>a.closeness-b.closeness).slice(0,20);
    const touched=pool.filter(r=>r.touchedAnyRecent).sort((a,b)=>Math.max(b.whenHighRecent||0,b.whenLowRecent||0)-Math.max(a.whenHighRecent||0,a.whenLowRecent||0)).slice(0,20);

    const line=x=>{
      const when = Math.max(x.whenHighRecent||0, x.whenLowRecent||0);
      return `<div class="rec-item">
        <div>
          <strong>${x.symbolDisp}</strong>
          <span class="pill">${x.market==="perp"?"Perp":"Spot"}</span>
          <a class="trade-btn" style="margin-left:8px" href="${tradeUrl(x.symbol)}" target="_blank" rel="noopener noreferrer">Trade</a>
        </div>
        <div class="note">close ${fmtN(x.closeness)}% ‚Ä¢ ${toIST12(when)}</div>
      </div>`;
    };
    recHigh.innerHTML=nearHigh.length?nearHigh.map(line).join(""):`<div class="note">None</div>`;
    recLow.innerHTML =nearLow.length ?nearLow.map(line).join(""):`<div class="note">None</div>`;
    recTouch.innerHTML=touched.length?touched.map(line).join(""):`<div class="note">None</div>`;
  }

  // Sorting
  $$("thead th").forEach(th=>{
    const k=th.getAttribute("data-k"); if(!k) return;
    th.addEventListener("click",()=>{
      if(state.sortKey===k) state.sortDir*=-1;
      else {state.sortKey=k; state.sortDir=1;}
      scheduleRender(); play.sort();
    },{passive:true});
  });

  // Events
  $("#marketType").addEventListener("change",async()=>{ state.marketType=$("#marketType").value; await withStatus(loadAll); },{passive:true});
  $$(".exch").forEach(cb=>cb.addEventListener("change",async()=>{
    state.exchanges=new Set($$(".exch").filter(x=>x.checked).map(x=>x.value));
    await withStatus(loadAll);
  },{passive:true}));
  $("#date").addEventListener("change",async()=>{ await withStatus(loadAll); },{passive:true});
  $("#timeIst").addEventListener("change",async()=>{ await withStatus(loadAll); },{passive:true});
  $("#tfSelect").addEventListener("change",async()=>{ state.timeframe=$("#tfSelect").value; await withStatus(loadAll); },{passive:true});
  $("#refresh").addEventListener("click",async()=>{ await withStatus(loadAll); });
  (function(){let t=null; $("#search").addEventListener("input",()=>{clearTimeout(t); t=setTimeout(()=>scheduleRender(),100);});})();
  $("#lookbackHrs").addEventListener("input",()=>{ state.lookbackHrs=Math.max(1,parseInt($("#lookbackHrs").value||"24",10)||24); },{passive:true});
  $("#filterRecent").addEventListener("change",()=>{ scheduleRender(); computeRecommendations(); },{passive:true});
  $("#threshold").addEventListener("input",e=>{
    state.rows.forEach(r=>Object.assign(r,compute(r.price,r.high,r.low)));
    scheduleRender(); computeRecommendations();
  },{passive:true});
  $("#maxClose").addEventListener("input",()=>{ scheduleRender(); computeRecommendations(); },{passive:true});

  $("#loadTop").addEventListener("click",async()=>{ await withStatus(async()=>{ await loadSymbolsTop(); await loadAll(); }); });
  $("#mcFetch").addEventListener("click",async()=>{ await fetchMarketCaps(); });

  $("#rvolCompute").addEventListener("click",async()=>{
    if(!hasPro()){ openPro("RVOL is Pro."); return; }
    await computeRVOLAll();
  });
  $("#ptCompute").addEventListener("click",async()=>{
    if(!hasPro()){ openPro("P@Target is Pro."); return; }
    await computePAtAll();
  });
  $("#scanRecentBtn").addEventListener("click",async()=>{
    // if you want it Pro, gate here; for now it is free in UI toggle above
    await scanRecentTouches();
  });

  async function withStatus(fn){
    setStatus("Working‚Ä¶");
    try{ await fn(); }
    finally{ setStatus("Ready"); }
  }

  // Load symbols
  async function loadSymbolsTop(){
    const n=parseInt($("#topn").value,10)||300;
    const m=state.marketType;
    const exs=Array.from(state.exchanges);
    const out=[];
    await Promise.all(exs.map(async ex=>{
      const a=Adapters[ex];
      try{
        const syms=await a.topSymbols(m,n);
        for(const s of syms) out.push({exchangeKey:ex,exchangeName:a.name,market:m,symbol:s});
      }catch{}
    }));
    state.symbols=out;
  }

  function clearSockets(){
    for(const ws of state.sockets){ try{ws.close()}catch{} }
    state.sockets=[];
    wsCount.textContent="0";
  }

  // Main load
  async function loadAll(){
    clearSockets();
    clearInterval(state.restPoll);
    state.rows.clear();
    scheduleRender();

    state.dateStr=$("#date").value || istDateLabelFromMs(Date.now());
    state.timeIst=($("#timeIst").value||"").trim()||null;

    if(!state.symbols.length) await loadSymbolsTop();

    for(const o of state.symbols){
      const key=`${o.exchangeKey}|${o.market}|${o.symbol}`;
      state.rows.set(key,{
        key,exchangeKey:o.exchangeKey,exchangeName:o.exchangeName,market:o.market,symbol:o.symbol,
        symbolDisp:o.symbol.endsWith("USDT")?o.symbol.replace("USDT","/USDT"):o.symbol,
        price:null,high:null,low:null,toHighPct:null,toLowPct:null,posPct:null,closer:"‚Äî",closeness:null,rangePct:null,
        touchedAnyRecent:false,whenHighRecent:null,whenLowRecent:null,mcap:null,qvol24h:null,avgQVol:null,rvol:null,
        pAt:null,toPtPct:null,
        date: timeLabelISTForWindow(state.dateStr,state.timeIst),
        dayDir:null
      });
    }
    scheduleRender();

    const groups={};
    for(const o of state.symbols){
      if(!state.exchanges.has(o.exchangeKey)) continue;
      if(o.market!==state.marketType) continue;
      const gk=`${o.exchangeKey}|${o.market}`;
      (groups[gk] ||= []).push(o.symbol);
    }

    // initial prices
    await Promise.all(Object.keys(groups).map(async gk=>{
      const [ex,market]=gk.split("|");
      const a=Adapters[ex];
      const list=groups[gk];
      try{
        const map=await a.batchPrices(market,list);
        map.forEach((p,sym)=>{
          const r=state.rows.get(`${ex}|${market}|${sym}`);
          if(r) r.price=p;
        });
      }catch{}
    }));
    scheduleRender();

    // 24h stats
    await Promise.all(Object.keys(groups).map(async gk=>{
      const [ex,market]=gk.split("|");
      const a=Adapters[ex];
      const list=groups[gk];
      try{
        const map=await a.batch24hStats(market,list);
        map.forEach((obj,sym)=>{
          const r=state.rows.get(`${ex}|${market}|${sym}`);
          if(r) r.qvol24h=obj.qvol||null;
        });
      }catch{}
    }));
    scheduleRender();

    // TF H/L + day dir
    const tf=state.timeframe;
    const tasks=[];
    Object.keys(groups).forEach(gk=>{
      const [ex,market]=gk.split("|");
      const a=Adapters[ex];
      const list=groups[gk];
      const perBatch=20;

      for(let i=0;i<list.length;i+=perBatch){
        const slice=list.slice(i,i+perBatch).map(async sym=>{
          const r=state.rows.get(`${ex}|${market}|${sym}`); if(!r) return;
          try{
            // daily direction
            try{
              const d=await a.klineDayOHLC(market,sym,state.dateStr);
              if(d){
                r.dayDir = (d.close>d.open) ? "Bullish" : (d.close<d.open ? "Bearish" : "Doji");
              }
            }catch{ r.dayDir=null; }

            // timeframe hi/lo
            if(tf && tf!=="auto"){
              const kl=await a.klineHL_candleAt(market,sym,tf,state.dateStr,state.timeIst);
              if(kl){ r.high=kl.high; r.low=kl.low; r.date=candleIstLabel(kl.open,tf); }
            }else{
              const hasTime=!!state.timeIst;
              const res=hasTime
                ? await a.klineHL_window(market,sym,state.dateStr,state.timeIst)
                : await (async()=>{ const d=await a.klineDayOHLC(market,sym,state.dateStr); return d?{high:d.high,low:d.low,open:d.openTs}:null; })();
              if(res){
                r.high=res.high; r.low=res.low;
                r.date = hasTime ? timeLabelISTForWindow(state.dateStr,state.timeIst) : candleIstLabel(res.open,"1d");
              }
            }
            if(isF(r.price)&&isF(r.high)&&isF(r.low)) Object.assign(r,compute(r.price,r.high,r.low));
          }catch{}
        });
        tasks.push(Promise.all(slice).then(()=>scheduleRender()));
      }
    });

    for(let i=0;i<tasks.length;i++){
      await tasks[i];
      if(i%6===0) await new Promise(res=>setTimeout(res,60));
    }

    // sockets (only binance)
    let socketCount=0;
    for(const gk of Object.keys(groups)){
      const [ex,market]=gk.split("|");
      const a=Adapters[ex];
      const list=groups[gk];
      if(a.connectWS){
        try{
          const conns=a.connectWS(market,list,(sym,price)=>{
            const r=state.rows.get(`${ex}|${market}|${sym}`); if(!r) return;
            r.price=price;
            if(isF(r.high)&&isF(r.low)) Object.assign(r,compute(r.price,r.high,r.low));
            if(isF(r.pAt)) r.toPtPct = ((r.price - r.pAt)/r.pAt)*100;
            scheduleRender();
          });
          socketCount+=(conns||[]).length;
          state.sockets.push(...(conns||[]));
        }catch{}
      }
    }
    wsCount.textContent=String(socketCount);

    // REST polling backup
    state.restPoll=setInterval(async()=>{
      await Promise.all(Object.keys(groups).map(async gk=>{
        const [ex,market]=gk.split("|");
        const a=Adapters[ex];
        const list=groups[gk];
        try{
          const map=await a.batchPrices(market,list);
          map.forEach((p,sym)=>{
            const r=state.rows.get(`${ex}|${market}|${sym}`); if(!r) return;
            r.price=p;
            if(isF(r.high)&&isF(r.low)) Object.assign(r,compute(r.price,r.high,r.low));
            if(isF(r.pAt)) r.toPtPct=((r.price-r.pAt)/r.pAt)*100;
          });
        }catch{}
      }));
      scheduleRender();
    },5000);

    computeRecommendations();
    play.done();
  }

  // Recent touches scan
  async function scanRecentTouches(){
    setStatus("Scanning recent touches‚Ä¶");
    const mins=(parseInt($("#lookbackHrs").value||"24",10)||24)*60;
    const rows=Array.from(state.rows.values()).filter(r=>isF(r.high)&&isF(r.low));
    let i=0;

    for(const r of rows){
      const a=Adapters[r.exchangeKey];
      try{
        // MEXC spot only; binance spot/perp supported similarly
        const end=Date.now();
        const start=end-Math.max(5,mins)*60e3;
        const interval=mins<=999?"1m":"5m";

        const base = (r.exchangeKey==="binance") ? a.base(r.market) : a.base();
        const ep = (r.exchangeKey==="binance")
          ? (r.market==="perp"?"/fapi/v1/klines":"/api/v3/klines")
          : "/api/v3/klines";

        const url=`${base}${ep}?symbol=${r.symbol}&interval=${interval}&startTime=${start}&endTime=${end}&limit=1000`;
        const res=await fetch(url); if(!res.ok) throw 0;
        const arr=await res.json();

        let hitH=false,hitL=false,whenH=null,whenL=null;
        for(const k of arr){
          const hi=+k[2], lo=+k[3], t=k[0];
          if(!hitH && hi>=r.high){hitH=true;whenH=t}
          if(!hitL && lo<=r.low ){hitL=true;whenL=t}
        }
        r.touchedAnyRecent=!!(hitH||hitL);
        r.whenHighRecent=whenH;
        r.whenLowRecent=whenL;
      }catch{
        r.touchedAnyRecent=false;
        r.whenHighRecent=r.whenLowRecent=null;
      }
      if((++i%16)===0){ scheduleRender(); await new Promise(res=>setTimeout(res,90)); }
    }

    scheduleRender(); computeRecommendations(); setStatus("Ready"); play.done();
  }

  // RVOL
  async function computeRVOLAll(){
    const days=Math.min(60,Math.max(5,parseInt($("#rvolDays").value||"20",10)||20));
    setStatus(`Computing RVOL (days=${days})‚Ä¶`);
    let known=0,i=0;

    const rows=Array.from(state.rows.values());
    for(const r of rows){
      const a=Adapters[r.exchangeKey];
      try{
        if(r.exchangeKey==="mexc" && r.market==="perp") throw 0;

        const base = (r.exchangeKey==="binance") ? a.base(r.market) : a.base();
        const ep   = (r.exchangeKey==="binance") ? (r.market==="perp"?"/fapi/v1/klines":"/api/v3/klines") : "/api/v3/klines";
        const url  = `${base}${ep}?symbol=${r.symbol}&interval=1d&limit=${days}`;

        const resp=await fetch(url); if(!resp.ok) throw 0;
        const arr=await resp.json(); if(!Array.isArray(arr)||arr.length<5) throw 0;

        let sum=0,cnt=0;
        for(const k of arr){
          const close=+k[4], baseVol=+k[5];
          const quoteVol=isF(+k[7])?+k[7]:(isF(baseVol)&&isF(close)? baseVol*close : NaN);
          if(isF(quoteVol)){sum+=quoteVol;cnt++;}
        }
        const avg=cnt?sum/cnt:null;

        if(isF(avg) && avg>0){
          r.avgQVol=avg;
          if(!isF(r.qvol24h)){
            try{
              const m=await a.batch24hStats(r.market,[r.symbol]);
              const st=m.get(r.symbol);
              if(st) r.qvol24h=st.qvol||null;
            }catch{}
          }
          if(isF(r.qvol24h) && r.qvol24h>=0){ r.rvol=r.qvol24h/avg; known++; }
          else r.rvol=null;
        }else{
          r.avgQVol=null; r.rvol=null;
        }
      }catch{
        r.avgQVol=null; r.rvol=null;
      }
      if((++i%12)===0){ rvKnown.textContent=String(known); scheduleRender(); await new Promise(res=>setTimeout(res,80)); }
    }

    rvKnown.textContent=String(known);
    scheduleRender(); computeRecommendations(); setStatus("Ready"); play.done();
  }

  // P@Target
  async function computePAtAll(){
    if(!state.timeIst){ alert("Please set a Target Time (IST) to compute P@Target."); return; }
    setStatus("Fetching P@Target (1m)‚Ä¶");
    let known=0, i=0;
    const rows=Array.from(state.rows.values());
    const concurrency=10;
    let idx=0;

    async function worker(){
      while(idx<rows.length){
        const r=rows[idx++];
        const a=Adapters[r.exchangeKey];
        try{
          const p=await a.priceAtTarget(r.market,r.symbol,state.dateStr,state.timeIst);
          if(isF(p)){
            r.pAt=p;
            r.toPtPct=((isF(r.price)?r.price:p)-p)/p*100;
            known++;
          }else{ r.pAt=null; r.toPtPct=null; }
        }catch{
          r.pAt=null; r.toPtPct=null;
        }
        if((i++%20)===0){ ptKnown.textContent=String(known); scheduleRender(); await new Promise(res=>setTimeout(res,60)); }
      }
    }

    await Promise.all(Array.from({length:concurrency},worker));
    ptKnown.textContent=String(known);
    scheduleRender(); setStatus(`Ready (${known} P@Target)`); play.done();
  }

  // Init
  (async function init(){
    state.marketType="spot";
    state.exchanges=new Set(["mexc"]); // default MEXC
    state.timeframe="auto";
    await loadSymbolsTop();
    await loadAll();
    setStatus("Ready");
  })();

  window.addEventListener("beforeunload",()=>{
    clearInterval(state.restPoll);
    for(const ws of state.sockets){ try{ws.close()}catch{} }
  });
})();
</script>

<script>
  // expose CONFIG safely for the 2nd script (optional)
  window.CONFIG = window.CONFIG || {};
</script>

</body>
</html>
